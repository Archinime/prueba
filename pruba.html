<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fondo + Chroma (ventana adaptable a aspecto del vídeo)</title>
  <style>
    /* Reset */
    html,body { height:100%; margin:0; background:#000; font-family: Arial, sans-serif; }
    .stage { position:relative; width:100%; height:100vh; overflow:hidden; }

    /* Fondo */
    video#bgVideo {
      position:fixed; inset:0; width:100%; height:100%; object-fit:cover;
      z-index:0; pointer-events:none; background:#000;
    }

    /* Contenedor adaptable: tamaño se asigna por JS según el aspecto del vídeo */
    #fgContainer {
      position:fixed;
      right:20px; bottom:20px;
      z-index:5;
      pointer-events:auto;
      display:flex; align-items:center; justify-content:center;
      transform: translateY(30px);
      opacity: 0;
      transition: transform 280ms ease-out, opacity 220ms ease-out;
      will-change: transform, opacity;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      border-radius: 8px;
      overflow: hidden;
      background: rgba(0,0,0,0.04);
      min-width: 120px; min-height: 80px;
      max-width: calc(70vw); max-height: calc(70vh);
    }

    /* Entrada / salida */
    #fgContainer.enter { transform: translateY(0); opacity: 1; }
    #fgContainer.exit  { transform: translateY(60px); opacity: 0; }

    /* Canvas y vídeo: ocupan todo el contenedor. Canvas usado para chroma (display block cuando activo) */
    canvas#fgCanvas, video#fgVideo {
      width:100%; height:100%; display:block;
      pointer-events:none;
      object-fit: contain; /* importante: muestra todo el vídeo sin recortar */
      background: transparent;
    }
    /* Inicialmente canvas visible (si chroma ok) — display toggled by JS */
    canvas#fgCanvas { display:none; }

    /* Controls (solo file://) */
    .controls {
      position:fixed; left:12px; bottom:12px; z-index:6;
      background: rgba(0,0,0,0.55); color:#fff; padding:10px; border-radius:8px;
      font-size:13px;
    }
    .controls label { display:block; margin:6px 0; }
    input[type=range]{ width:180px; }

    /* Play overlay */
    .play-overlay {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      z-index:9; pointer-events:auto;
    }
    .play-btn {
      background: rgba(0,0,0,0.7); color:#fff; border:2px solid #fff;
      padding:14px 22px; border-radius:12px; font-size:18px; cursor:pointer;
    }

    /* Mensajes */
    .notice { position:fixed; top:12px; right:12px; z-index:10; background:#ffb74d; color:#000; padding:8px 12px; border-radius:8px; font-weight:600; display:none; }
    .error  { position:fixed; top:12px; left:12px; z-index:10; background:#ff4d4d; color:#fff; padding:8px 12px; border-radius:8px; font-weight:600; display:none; }

    /* Hint */
    #fgContainer .hint {
      position:absolute; left:8px; top:6px; z-index:6; font-size:12px; color:rgba(255,255,255,0.95);
      text-shadow: 0 1px 2px rgba(0,0,0,0.55);
      pointer-events:none;
    }

    @media (max-width:420px) {
      #fgContainer { right:12px; bottom:12px; }
    }
  </style>
</head>
<body>
  <div class="stage">
    <!-- Fondo -->
    <video id="bgVideo" autoplay muted loop playsinline>
      <source src="https://www.dropbox.com/scl/fi/ex4qhvjtx54blr92d0saj/yyyy.mp4?rlkey=ip9vhlhlsl1ye7el3onl1u2ug&st=f8o90thc&raw=1" type="video/mp4">
      Tu navegador no soporta vídeo.
    </video>

    <!-- Contenedor adaptable para el frontal -->
    <div id="fgContainer" aria-label="Vídeo frontal (haz clic para ocultar)">
      <div class="hint">Haz clic para ocultar</div>
      <canvas id="fgCanvas"></canvas>
      <video id="fgVideo" src="hola.mp4" muted loop playsinline></video>
    </div>

    <!-- Controles (JS decide mostrar si file://) -->
    <div class="controls" id="controls" style="display:none;">
      <div style="font-weight:700; margin-bottom:6px;">Chroma key — Ajustes (solo file://)</div>
      <label>Umbral de verde (sensibilidad): <span id="thVal">0.40</span>
        <input id="threshold" type="range" min="0.0" max="1.0" step="0.01" value="0.40">
      </label>
      <label>Diferencia mínima G - max(R,B): <span id="diffVal">30</span>
        <input id="diff" type="range" min="0" max="255" step="1" value="30">
      </label>
      <label>Suavizado (bordes): <span id="softVal">30</span>
        <input id="soft" type="range" min="0" max="200" step="1" value="30">
      </label>
    </div>

    <!-- Play overlay -->
    <div class="play-overlay" id="playOverlay" style="display:none;">
      <button class="play-btn" id="playBtn">Pulsar para iniciar</button>
    </div>

    <!-- Mensajes -->
    <div id="noticeBox" class="notice">Chroma-key no disponible; mostrando vídeo sin recorte.</div>
    <div id="errorBox" class="error">Error procesando el vídeo frontal (no se pueden leer píxeles).</div>
  </div>

<script>
/* Elementos y variables */
const protocol = location.protocol; // 'file:', 'http:', 'https:'
const fgContainer = document.getElementById('fgContainer');
const fgCanvas = document.getElementById('fgCanvas');
const fgVideo = document.getElementById('fgVideo'); // hola.mp4 local
const bgVideo = document.getElementById('bgVideo');
const ctx = fgCanvas.getContext('2d', { alpha: true });

const controls = document.getElementById('controls');
const thresholdEl = document.getElementById('threshold');
const diffEl = document.getElementById('diff');
const softEl = document.getElementById('soft');
const thVal = document.getElementById('thVal');
const diffVal = document.getElementById('diffVal');
const softVal = document.getElementById('softVal');

const playOverlay = document.getElementById('playOverlay');
const playBtn = document.getElementById('playBtn');
const noticeBox = document.getElementById('noticeBox');
const errorBox = document.getElementById('errorBox');

let off = document.createElement('canvas');
let offCtx = off.getContext('2d');
let animationId = null;
let usingChroma = true;

/* Preset para HTTP(S) */
const PRESET_HTTP = { threshold: 0.25, diff: 0, soft: 100 };

/* Mostrar/ocultar controles según protocolo */
function setupControlsByProtocol() {
  if (protocol === 'file:') {
    controls.style.display = 'block';
    // mantener valores iniciales
  } else {
    controls.style.display = 'none';
    thresholdEl.value = PRESET_HTTP.threshold;
    diffEl.value = PRESET_HTTP.diff;
    softEl.value = PRESET_HTTP.soft;
    thVal.textContent = PRESET_HTTP.threshold.toFixed(2);
    diffVal.textContent = PRESET_HTTP.diff;
    softVal.textContent = PRESET_HTTP.soft;
  }
}

/* Ajustar tamaño del contenedor según la relación de aspecto del vídeo */
function adjustContainerToVideo(video) {
  const vw = video.videoWidth || 16;
  const vh = video.videoHeight || 9;
  // límites: no más del 70vw / 70vh; tampoco queremos que crezca demasiado en pantallas grandes
  const maxW = Math.min(window.innerWidth * 0.7, 800); // px
  const maxH = Math.min(window.innerHeight * 0.7, 800);
  // calc scale to fit (contain)
  const scale = Math.min(maxW / vw, maxH / vh, 1.0);
  const displayW = Math.max(120, Math.round(vw * scale)); // min width safeguard
  const displayH = Math.max(80, Math.round(vh * scale));
  // apply to container
  fgContainer.style.width = displayW + 'px';
  fgContainer.style.height = displayH + 'px';
  // set canvas pixel size to match container for crisp rendering
  fgCanvas.width = displayW;
  fgCanvas.height = displayH;
  // Offscreen: use video natural resolution but cap to 1280x1280 for perf
  const cap = 1280;
  off.width = Math.min(video.videoWidth || displayW, cap);
  off.height = Math.min(video.videoHeight || displayH, cap);
}

/* Chroma-key algorithm */
function applyChromaKey(imageData, settings) {
  const data = imageData.data;
  const len = data.length;
  const thresh = settings.threshold;
  const minDiff = settings.diff;
  const soften = settings.soft;
  for (let i = 0; i < len; i += 4) {
    const r = data[i], g = data[i+1], b = data[i+2], a = data[i+3];
    if (a === 0) continue;
    const maxrb = Math.max(r,b);
    const sum = r + g + b + 1;
    const greenScore = (g - maxrb) / sum;
    const isGreenCandidate = (g - maxrb) > minDiff && greenScore > (thresh - 0.2);
    if (!isGreenCandidate) {
      data[i+3] = 255;
      continue;
    }
    const diff = g - maxrb;
    if (soften <= 0) {
      data[i+3] = (diff > minDiff) ? 0 : 255;
    } else {
      const t = (diff - minDiff) / soften;
      const clamped = Math.max(0, Math.min(1, t));
      data[i+3] = Math.round((1 - clamped) * 255);
    }
  }
  return imageData;
}

/* Draw processed off canvas into fgCanvas using 'contain' (show whole video) */
function drawProcessedToScreen() {
  const cw = fgCanvas.width, ch = fgCanvas.height;
  const vw = off.width, vh = off.height;
  ctx.clearRect(0,0,cw,ch);
  if (vw === 0 || vh === 0) return;
  // contain scale (fit whole)
  const scale = Math.min(cw / vw, ch / vh);
  const dw = Math.round(vw * scale);
  const dh = Math.round(vh * scale);
  const dx = Math.round((cw - dw) / 2);
  const dy = Math.round((ch - dh) / 2);
  ctx.drawImage(off, 0, 0, vw, vh, dx, dy, dw, dh);
}

/* Processing loop */
function processLoop(video) {
  if (!usingChroma) return;
  if (video.paused || video.ended) {
    animationId = requestAnimationFrame(()=>processLoop(video));
    return;
  }

  // Adjust off to video resolution if changed (cap applied earlier)
  if (video.videoWidth && video.videoHeight &&
      (off.width !== Math.min(video.videoWidth,1280) || off.height !== Math.min(video.videoHeight,1280))) {
    off.width = Math.min(video.videoWidth, 1280);
    off.height = Math.min(video.videoHeight, 1280);
  }

  try {
    offCtx.drawImage(video, 0, 0, off.width, off.height);
  } catch (err) {
    console.error('drawImage error (posible CORS):', err);
    activateFallback('No se pudieron leer píxeles (CORS). Mostrando vídeo sin recorte.');
    return;
  }

  let frame;
  try {
    frame = offCtx.getImageData(0, 0, off.width, off.height);
  } catch (err) {
    console.error('getImageData error (CORS):', err);
    activateFallback('No se pudieron leer píxeles (CORS). Mostrando vídeo sin recorte.');
    return;
  }

  const settings = {
    threshold: parseFloat(thresholdEl.value),
    diff: parseInt(diffEl.value, 10),
    soft: parseInt(softEl.value, 10)
  };
  thVal.textContent = settings.threshold.toFixed(2);
  diffVal.textContent = settings.diff;
  softVal.textContent = settings.soft;

  const processed = applyChromaKey(frame, settings);
  offCtx.putImageData(processed, 0, 0);
  drawProcessedToScreen();

  animationId = requestAnimationFrame(()=>processLoop(video));
}

/* Fallback: show video element without chroma */
function activateFallback(message) {
  usingChroma = false;
  fgCanvas.style.display = 'none';
  fgVideo.style.display = 'block';
  noticeBox.textContent = message || 'Chroma-key no disponible; mostrando vídeo sin recorte.';
  noticeBox.style.display = 'block';
  if (animationId) cancelAnimationFrame(animationId);
  fgVideo.play().catch(()=>{ playOverlay.style.display = 'flex'; });
  showContainer();
}

/* Show container (entry animation) */
function showContainer() {
  fgContainer.style.display = 'flex';
  fgContainer.classList.remove('exit');
  requestAnimationFrame(()=> fgContainer.classList.add('enter'));
}

/* Hide container with animation */
function hideContainerWithAnimation() {
  fgContainer.classList.remove('enter');
  fgContainer.classList.add('exit');
  setTimeout(()=> {
    fgContainer.style.display = 'none';
    try { fgVideo.pause(); } catch(e){}
    if (animationId) cancelAnimationFrame(animationId);
  }, 340);
}

/* Try autoplay */
function tryAutoplayBoth(procVideo) {
  const p1 = bgVideo.play().catch(()=>{});
  let p2;
  if (procVideo) p2 = procVideo.play().catch(()=>{});
  else p2 = fgVideo.play().catch(()=>{});
  Promise.allSettled([p1, p2]).then(results => {
    const anyRejected = results.some(r => r.status === 'rejected');
    if (anyRejected) {
      playOverlay.style.display = 'flex';
    } else {
      playOverlay.style.display = 'none';
      showContainer();
      if (usingChroma && procVideo) {
        if (!animationId) animationId = requestAnimationFrame(()=>processLoop(procVideo));
      } else {
        fgCanvas.style.display = usingChroma ? 'block' : 'none';
        fgVideo.style.display = usingChroma ? 'none' : 'block';
      }
    }
  });
}

/* Inicialización */
function init() {
  setupControlsByProtocol();

  // prepare container initial hidden state
  fgContainer.style.display = 'none';

  // When video metadata loaded, adapt container to video's aspect ratio
  fgVideo.addEventListener('loadedmetadata', () => {
    adjustContainerToVideo(fgVideo);

    // If HTTP/HTTPS, we use preset values already set earlier; if file:// user can adjust
    // Try autoplay and start chroma processing (processing will fall back on CORS errors)
    // Show canvas initially and start processing
    fgCanvas.style.display = 'block';
    fgVideo.style.display = 'none';
    tryAutoplayBoth(fgVideo);
    // Start processing loop (will handle CORS/getImageData errors)
    if (!animationId && usingChroma) animationId = requestAnimationFrame(()=>processLoop(fgVideo));
  });

  // handle load errors
  fgVideo.addEventListener('error', (e) => {
    console.error('Error cargando hola.mp4', e);
    activateFallback('Error cargando el vídeo frontal. Mostrando fallback (sin recorte).');
  });

  // update container size on window resize to keep it within screen
  window.addEventListener('resize', () => {
    // if video metadata exists, re-adjust
    if (fgVideo.videoWidth && fgVideo.videoHeight) adjustContainerToVideo(fgVideo);
  });

  // click to hide container
  fgContainer.addEventListener('click', (e) => {
    if (fgContainer.style.display === 'none') return;
    hideContainerWithAnimation();
  });

  // play button handler
  playBtn.addEventListener('click', () => {
    playOverlay.style.display = 'none';
    bgVideo.play().catch(()=>{});
    fgVideo.play().then(()=> {
      if (usingChroma) {
        fgCanvas.style.display = 'block';
        fgVideo.style.display = 'none';
        if (!animationId) animationId = requestAnimationFrame(()=>processLoop(fgVideo));
      } else {
        fgVideo.style.display = 'block';
        fgCanvas.style.display = 'none';
      }
      showContainer();
    }).catch(()=> {
      activateFallback('No se pudo iniciar reproducción automáticamente.');
    });
  });

  // controls update display values
  [thresholdEl, diffEl, softEl].forEach(el => el.addEventListener('input', () => {
    thVal.textContent = parseFloat(thresholdEl.value).toFixed(2);
    diffVal.textContent = diffEl.value;
    softVal.textContent = softEl.value;
  }));
}

/* Start */
init();

</script>
</body>
</html>
