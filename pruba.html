<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fondo + Chroma (ventana pequeña en esquina)</title>
  <style>
    /* Reset básico */
    html,body { height:100%; margin:0; background:#000; font-family: Arial, sans-serif; }
    .stage { position:relative; width:100%; height:100vh; overflow:hidden; }

    /* Vídeo de fondo */
    video#bgVideo {
      position:fixed; inset:0;
      width:100%; height:100%; object-fit:cover;
      z-index:0; pointer-events:none; background:#000;
    }

    /* Contenedor pequeño en esquina para el elemento frontal (canvas o video fallback) */
    #fgContainer {
      position:fixed;
      right:20px; bottom:20px;
      width:360px;    /* ancho reducido - cambia si quieres */
      height:202px;   /* alto acorde (16:9 ~ 360x202) */
      z-index:5;
      pointer-events:auto; /* permitimos clic para cerrar */
      display:flex; align-items:center; justify-content:center;
      transform: translateY(30px);
      opacity: 0;
      transition: transform 280ms ease-out, opacity 220ms ease-out;
      will-change: transform, opacity;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      border-radius: 8px;
      overflow: hidden;
      background: rgba(0,0,0,0.05);
    }

    /* estado visible (entrada desde abajo) */
    #fgContainer.enter {
      transform: translateY(0);
      opacity: 1;
    }

    /* estado de salida (bajar y desaparecer) */
    #fgContainer.exit {
      transform: translateY(60px);
      opacity: 0;
    }

    /* Canvas visible (será exactamente el tamaño del contenedor) */
    canvas#fgCanvas {
      width:100%; height:100%; display:block;
      pointer-events:none; /* el click lo recibe el contenedor */
      background: transparent;
    }

    /* Vídeo fallback (si no podemos chroma): lo mostramos dentro del mismo contenedor */
    video#fgVideo {
      width:100%; height:100%; object-fit:cover; display:none;
    }

    /* Controles: SOLO visibles en file:// (controlado por JS) */
    .controls {
      position:fixed; left:12px; bottom:12px; z-index:6;
      background: rgba(0,0,0,0.55); color:#fff; padding:10px; border-radius:8px;
      font-size:13px;
    }
    .controls label { display:block; margin:6px 0; }
    input[type=range]{ width:180px; }

    /* Botón grande si autoplay bloqueado */
    .play-overlay {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      z-index:9; pointer-events:auto;
    }
    .play-btn {
      background: rgba(0,0,0,0.7); color:#fff; border:2px solid #fff;
      padding:14px 22px; border-radius:12px; font-size:18px; cursor:pointer;
    }

    /* Mensajes cortos */
    .notice { position:fixed; top:12px; right:12px; z-index:10; background:#ffb74d; color:#000; padding:8px 12px; border-radius:8px; font-weight:600; display:none; }
    .error  { position:fixed; top:12px; left:12px; z-index:10; background:#ff4d4d; color:#fff; padding:8px 12px; border-radius:8px; font-weight:600; display:none; }

    /* Pequeño borde para indicar que se puede clicar (opcional) */
    #fgContainer .hint {
      position:absolute; left:8px; top:6px; z-index:6; font-size:12px; color:rgba(255,255,255,0.85);
      text-shadow: 0 1px 2px rgba(0,0,0,0.6);
    }

    @media (max-width:420px) {
      /* reducir en pantallas muy pequeñas */
      #fgContainer { width:260px; height:146px; right:12px; bottom:12px; }
    }
  </style>
</head>
<body>
  <div class="stage">
    <!-- Fondo (tu link Dropbox) -->
    <video id="bgVideo" autoplay muted loop playsinline>
      <source src="https://www.dropbox.com/scl/fi/ex4qhvjtx54blr92d0saj/yyyy.mp4?rlkey=ip9vhlhlsl1ye7el3onl1u2ug&st=f8o90thc&raw=1" type="video/mp4">
      Tu navegador no soporta vídeo.
    </video>

    <!-- Contenedor pequeño para el elemento frontal (canvas procesado o video fallback) -->
    <div id="fgContainer" aria-label="Vídeo frontal (click para cerrar)">
      <div class="hint">Haz clic para ocultar</div>
      <!-- Canvas que mostrará el resultado del chroma-key (si está disponible) -->
      <canvas id="fgCanvas" width="360" height="202"></canvas>

      <!-- Vídeo fallback (se mostrará si chroma no es posible) -->
      <video id="fgVideo" src="hola.mp4" muted loop playsinline></video>
    </div>

    <!-- Controles: aparecerán SOLO si page protocol === 'file:' (JS los muestra/oculta) -->
    <div class="controls" id="controls" style="display:none;">
      <div style="font-weight:700; margin-bottom:6px;">Chroma key — Ajustes (solo file://)</div>
      <label>Umbral de verde (sensibilidad): <span id="thVal">0.40</span>
        <input id="threshold" type="range" min="0.0" max="1.0" step="0.01" value="0.40">
      </label>
      <label>Diferencia mínima G - max(R,B): <span id="diffVal">30</span>
        <input id="diff" type="range" min="0" max="255" step="1" value="30">
      </label>
      <label>Suavizado (bordes): <span id="softVal">30</span>
        <input id="soft" type="range" min="0" max="200" step="1" value="30">
      </label>
    </div>

    <!-- Overlay play si autoplay bloqueado -->
    <div class="play-overlay" id="playOverlay" style="display:none;">
      <button class="play-btn" id="playBtn">Pulsar para iniciar</button>
    </div>

    <!-- Mensajes -->
    <div id="noticeBox" class="notice">Chroma-key no disponible; mostrando vídeo sin recorte.</div>
    <div id="errorBox" class="error">Error procesando el vídeo frontal (no se pueden leer píxeles).</div>
  </div>

<script>
/* Variables y elementos */
const protocol = location.protocol; // 'file:', 'http:', 'https:'
const fgContainer = document.getElementById('fgContainer');
const fgCanvas = document.getElementById('fgCanvas');
const fgVideo = document.getElementById('fgVideo'); // fallback local hola.mp4
const bgVideo = document.getElementById('bgVideo');
const ctx = fgCanvas.getContext('2d', { alpha: true });

const controls = document.getElementById('controls');
const thresholdEl = document.getElementById('threshold');
const diffEl = document.getElementById('diff');
const softEl = document.getElementById('soft');
const thVal = document.getElementById('thVal');
const diffVal = document.getElementById('diffVal');
const softVal = document.getElementById('softVal');

const playOverlay = document.getElementById('playOverlay');
const playBtn = document.getElementById('playBtn');
const noticeBox = document.getElementById('noticeBox');
const errorBox = document.getElementById('errorBox');

let off = document.createElement('canvas');
let offCtx = off.getContext('2d');
let animationId = null;
let usingChroma = true; // inicialmente intentamos chroma

/* PRESETS: para http/https queremos los valores personalizados que pediste */
const PRESET_HTTP = { threshold: 0.25, diff: 0, soft: 100 };

/* Detectar entorno: si estamos abriendo con file:// mostramos controles, sino ocultamos y aplicamos preset */
function setupControlsByProtocol() {
  if (protocol === 'file:') {
    controls.style.display = 'block';
    // dejar los valores por defecto como están (usuario puede ajustar)
  } else {
    // http/https: ocultar controles y aplicar preset
    controls.style.display = 'none';
    thresholdEl.value = PRESET_HTTP.threshold;
    diffEl.value = PRESET_HTTP.diff;
    softEl.value = PRESET_HTTP.soft;
    thVal.textContent = PRESET_HTTP.threshold.toFixed(2);
    diffVal.textContent = PRESET_HTTP.diff;
    softVal.textContent = PRESET_HTTP.soft;
  }
}

/* Aplicar chroma-key a ImageData (idéntico algoritmo pero parametrizable) */
function applyChromaKey(imageData, settings) {
  const data = imageData.data;
  const len = data.length;
  const thresh = settings.threshold;
  const minDiff = settings.diff;
  const soften = settings.soft;

  for (let i = 0; i < len; i += 4) {
    const r = data[i], g = data[i+1], b = data[i+2], a = data[i+3];
    if (a === 0) continue;
    const maxrb = Math.max(r,b);
    const sum = r + g + b + 1;
    const greenScore = (g - maxrb) / sum;
    const isGreenCandidate = (g - maxrb) > minDiff && greenScore > (thresh - 0.2);
    if (!isGreenCandidate) {
      data[i+3] = 255;
      continue;
    }
    const diff = g - maxrb;
    if (soften <= 0) {
      data[i+3] = (diff > minDiff) ? 0 : 255;
    } else {
      const t = (diff - minDiff) / soften;
      const clamped = Math.max(0, Math.min(1, t));
      data[i+3] = Math.round((1 - clamped) * 255);
    }
  }
  return imageData;
}

/* Dibujar processed off canvas escalado al tamaño del canvas visible (la caja reducida) */
function drawProcessedToScreen() {
  // off is the processing canvas with natural/video resolution
  const cw = fgCanvas.width, ch = fgCanvas.height;
  const vw = off.width, vh = off.height;
  ctx.clearRect(0,0,cw,ch);
  if (vw === 0 || vh === 0) return;
  // cover-stretch en la pequeña caja (si quieres 'contain' cambia la lógica)
  const scale = Math.max(cw / vw, ch / vh);
  const dw = vw * scale, dh = vh * scale;
  const dx = (cw - dw)/2, dy = (ch - dh)/2;
  ctx.drawImage(off, 0,0, vw, vh, dx, dy, dw, dh);
}

/* Loop de proceso del chroma-key */
function processLoop(video) {
  if (!usingChroma) return;
  if (video.paused || video.ended) {
    animationId = requestAnimationFrame(()=>processLoop(video));
    return;
  }

  // ajustar off a resolución del vídeo si se puede
  if (video.videoWidth && video.videoHeight &&
      (off.width !== video.videoWidth || off.height !== video.videoHeight)) {
    off.width = video.videoWidth;
    off.height = video.videoHeight;
  }

  try {
    offCtx.drawImage(video, 0, 0, off.width, off.height);
  } catch (err) {
    console.error('drawImage error (posible CORS):', err);
    activateFallback('No se pudieron leer píxeles (CORS). Mostrando vídeo sin recorte.');
    return;
  }

  let frame;
  try {
    frame = offCtx.getImageData(0,0, off.width, off.height);
  } catch (err) {
    console.error('getImageData error (CORS):', err);
    activateFallback('No se pudieron leer píxeles (CORS). Mostrando vídeo sin recorte.');
    return;
  }

  const settings = {
    threshold: parseFloat(thresholdEl.value),
    diff: parseInt(diffEl.value, 10),
    soft: parseInt(softEl.value, 10)
  };
  thVal.textContent = settings.threshold.toFixed(2);
  diffVal.textContent = settings.diff;
  softVal.textContent = settings.soft;

  const processed = applyChromaKey(frame, settings);
  offCtx.putImageData(processed, 0, 0);
  drawProcessedToScreen();

  animationId = requestAnimationFrame(()=>processLoop(video));
}

/* Fallback: mostrar el vídeo tal cual (sin chroma) en el mismo contenedor */
function activateFallback(message) {
  usingChroma = false;
  // ocultar canvas y mostrar elemento video fallback
  fgCanvas.style.display = 'none';
  fgVideo.style.display = 'block';
  noticeBox.textContent = message || 'Chroma-key no disponible; mostrando vídeo sin recorte.';
  noticeBox.style.display = 'block';
  if (animationId) cancelAnimationFrame(animationId);
  // intentar play; si falla, mostrará overlay para iniciar
  fgVideo.play().catch(()=>{ playOverlay.style.display = 'flex'; });
  // asegurar que el contenedor esté visible
  showContainer();
}

/* Mostrar el contenedor con animación desde abajo */
function showContainer() {
  // for entrada: add .enter class (refresh for animation)
  fgContainer.classList.remove('exit');
  // allow next frame to transition
  requestAnimationFrame(()=> fgContainer.classList.add('enter'));
}

/* Ocultar contenedor con animación y luego ocultarlo del DOM visual */
function hideContainerWithAnimation() {
  fgContainer.classList.remove('enter');
  fgContainer.classList.add('exit');
  // tras la transición (300ms) esconderlo (para que no cambie foco)
  setTimeout(()=> {
    fgContainer.style.display = 'none';
    // opcional: stop playback/loop
    try { fgVideo.pause(); } catch(e){}
    if (animationId) cancelAnimationFrame(animationId);
  }, 340);
}

/* Manejo de autoplay: si se bloquea mostramos botón */
function tryAutoplayBoth(procVideo) {
  const p1 = bgVideo.play().catch(()=>{});
  let p2;
  if (procVideo) {
    p2 = procVideo.play().catch(()=>{});
  } else {
    p2 = fgVideo.play().catch(()=>{});
  }
  Promise.allSettled([p1, p2]).then(results => {
    const anyRejected = results.some(r => r.status === 'rejected');
    if (anyRejected) {
      playOverlay.style.display = 'flex';
    } else {
      playOverlay.style.display = 'none';
      showContainer();
      if (usingChroma && procVideo) {
        if (!animationId) animationId = requestAnimationFrame(()=>processLoop(procVideo));
      } else {
        fgCanvas.style.display = usingChroma ? 'block' : 'none';
        fgVideo.style.display = usingChroma ? 'none' : 'block';
      }
    }
  });
}

/* Inicialización principal: usamos el vídeo local hola.mp4 para procesar (same origin expected when hosted together)
   Si el navegador impide leer pixels (por ejemplo cuando se abre via file:// con ciertas restricciones o por CORS),
   el código activará fallback. */
function init() {
  setupControlsByProtocol();

  // garantizamos que canvas tenga las dimensiones de la caja reducida
  const containerStyle = window.getComputedStyle(fgContainer);
  const width = parseInt(containerStyle.width,10) || fgCanvas.width;
  const height = parseInt(containerStyle.height,10) || fgCanvas.height;
  fgCanvas.width = width;
  fgCanvas.height = height;

  // Preparamos off canvas razonable; se ajustará cuando loadedmetadata llegue
  off.width = Math.max(640, fgCanvas.width * 2);
  off.height = Math.max(360, fgCanvas.height * 2);

  // Intentamos usar fgVideo (hola.mp4) como vídeo de procesamiento
  // Si la página está en http/https *y* hola.mp4 está en misma servidor, chromakey debería funcionar.
  // Si se abre en file:// y navegador lo permite, también debería funcionar. Si no -> fallback.
  // Escuchamos loadedmetadata para configurar off a resolución natural
  fgVideo.addEventListener('loadedmetadata', () => {
    off.width = fgVideo.videoWidth || off.width;
    off.height = fgVideo.videoHeight || off.height;
  });

  fgVideo.addEventListener('error', (e) => {
    console.error('Error cargando hola.mp4', e);
    activateFallback('Error cargando el vídeo frontal. Mostrando fallback (sin recorte).');
  });

  // Intentamos arrancar chroma: requerirá que fgVideo pueda reproducirse y que getImageData funcione
  // Por seguridad, intentamos reproducir el video en background; si autoplay bloqueado, mostramos botón
  // Para proteger contra errores CORS, el loop de processLoop manejará y activará fallback si getImageData falla
  tryAutoplayBoth(fgVideo);

  // Si el usuario abre via file://, dejamos controles visibles; sino (http/https) aplicamos presets
  // (esto ya hecho en setupControlsByProtocol)
}

/* Click en el contenedor => hacer desaparecer con animación */
fgContainer.addEventListener('click', (e) => {
  // Solo responder si está visible
  if (fgContainer.style.display === 'none') return;
  hideContainerWithAnimation();
});

/* Botón play */
playBtn.addEventListener('click', () => {
  playOverlay.style.display = 'none';
  // intentar reproducir ambos elementos
  bgVideo.play().catch(()=>{});
  fgVideo.play().then(()=> {
    // si usingChroma true, lanzamos loop
    if (usingChroma) {
      fgCanvas.style.display = 'block';
      fgVideo.style.display = 'none';
      if (!animationId) animationId = requestAnimationFrame(()=>processLoop(fgVideo));
    } else {
      fgVideo.style.display = 'block';
      fgCanvas.style.display = 'none';
    }
    showContainer();
  }).catch(()=> {
    // si no puede reproducir, mostramos fallback (video visible) y overlay se mantiene si necesario
    activateFallback('No se pudo iniciar reproducción automáticamente.');
  });
});

/* Si el usuario abre por file:// queremos mostrar controles interactivos:
   Actualizar valores visuales cuando cambian */
[thresholdEl, diffEl, softEl].forEach(el => el.addEventListener('input', () => {
  thVal.textContent = parseFloat(thresholdEl.value).toFixed(2);
  diffVal.textContent = diffEl.value;
  softVal.textContent = softEl.value;
}));

/* Start */
init();

</script>
</body>
</html>
