<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fondo + Chroma (playlist aleatoria hola/rem)</title>
  <style>
    /* Reset */
    html,body { height:100%; margin:0; background:#000; font-family: Arial, sans-serif; }
    .stage { position:relative; width:100%; height:100vh; overflow:hidden; }

    /* Fondo */
    video#bgVideo {
      position:fixed; inset:0; width:100%; height:100%; object-fit:cover;
      z-index:0; pointer-events:none; background:#000;
    }

    /* Contenedor adaptable para el frontal
       -> Se quitaron fondo, sombra y cualquier marco visible para que no parezca recuadro */
    #fgContainer {
      position:fixed;
      /* left/right se asignan dinámicamente (aleatorio) */
      bottom:20px;
      z-index:5;
      pointer-events:auto;
      display:flex; align-items:center; justify-content:center;
      transform: translateY(30px);
      opacity: 0;
      transition: transform 280ms ease-out, opacity 220ms ease-out;
      will-change: transform, opacity;
      overflow: hidden;
      min-width: 120px; min-height: 80px;
      max-width: calc(70vw); max-height: calc(70vh);
      /* removed box-shadow and background to hide any visible frame */
      box-shadow: none;
      background: transparent;
      border-radius: 0;
    }

    /* Entrada / salida */
    #fgContainer.enter { transform: translateY(0); opacity: 1; }
    #fgContainer.exit  { transform: translateY(60px); opacity: 0; }

    /* Canvas y vídeo: ocupan todo el contenedor. */
    canvas#fgCanvas, video#fgVideo {
      width:100%; height:100%; display:block;
      pointer-events:none;
      object-fit: contain; /* muestra todo el vídeo sin recortar */
      background: transparent;
    }
    /* Iniciamos canvas oculto; JS decide mostrar */
    canvas#fgCanvas { display:none; }

    /* Controls (solo file://) */
    .controls {
      position:fixed; left:12px; bottom:12px; z-index:6;
      background: rgba(0,0,0,0.55); color:#fff; padding:10px; border-radius:8px;
      font-size:13px;
    }
    .controls label { display:block; margin:6px 0; }
    input[type=range]{ width:180px; }

    /* Play overlay */
    .play-overlay {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      z-index:9; pointer-events:auto;
    }
    .play-btn {
      background: rgba(0,0,0,0.7); color:#fff; border:2px solid #fff;
      padding:14px 22px; border-radius:12px; font-size:18px; cursor:pointer;
    }

    /* Mensajes */
    .notice { position:fixed; top:12px; right:12px; z-index:10; background:#ffb74d; color:#000; padding:8px 12px; border-radius:8px; font-weight:600; display:none; }
    .error  { position:fixed; top:12px; left:12px; z-index:10; background:#ff4d4d; color:#fff; padding:8px 12px; border-radius:8px; font-weight:600; display:none; }

    @media (max-width:420px) {
      #fgContainer { bottom:12px; }
    }
  </style>
</head>
<body>
  <div class="stage">
    <!-- Fondo -->
    <video id="bgVideo" autoplay muted loop playsinline>
      <source src="https://www.dropbox.com/scl/fi/ex4qhvjtx54blr92d0saj/yyyy.mp4?rlkey=ip9vhlhlsl1ye7el3onl1u2ug&st=f8o90thc&raw=1" type="video/mp4">
      Tu navegador no soporta vídeo.
    </video>

    <!-- Contenedor adaptable para el frontal (sin marco visible) -->
    <div id="fgContainer" aria-label="Vídeo frontal">
      <canvas id="fgCanvas"></canvas>
      <video id="fgVideo" muted loop playsinline></video>
    </div>

    <!-- Controles (JS decide mostrar si file://) -->
    <div class="controls" id="controls" style="display:none;">
      <div style="font-weight:700; margin-bottom:6px;">Chroma key — Ajustes (solo file://)</div>
      <label>Umbral de verde (sensibilidad): <span id="thVal">0.40</span>
        <input id="threshold" type="range" min="0.0" max="1.0" step="0.01" value="0.40">
      </label>
      <label>Diferencia mínima G - max(R,B): <span id="diffVal">30</span>
        <input id="diff" type="range" min="0" max="255" step="1" value="30">
      </label>
      <label>Suavizado (bordes): <span id="softVal">30</span>
        <input id="soft" type="range" min="0" max="200" step="1" value="30">
      </label>
    </div>

    <!-- Play overlay -->
    <div class="play-overlay" id="playOverlay" style="display:none;">
      <button class="play-btn" id="playBtn">Pulsar para iniciar</button>
    </div>

    <!-- Mensajes -->
    <div id="noticeBox" class="notice">Chroma-key no disponible; mostrando vídeo sin recorte.</div>
    <div id="errorBox" class="error">Error procesando el vídeo frontal (no se pueden leer píxeles).</div>
  </div>

<script>
/* CONFIG y ELEMENTOS */
const protocol = location.protocol; // 'file:', 'http:', 'https:'
const fgContainer = document.getElementById('fgContainer');
const fgCanvas = document.getElementById('fgCanvas');
const fgVideo = document.getElementById('fgVideo'); // elemento video que usaremos para reproducir cada clip
const bgVideo = document.getElementById('bgVideo');
const ctx = fgCanvas.getContext('2d', { alpha: true });

const controls = document.getElementById('controls');
const thresholdEl = document.getElementById('threshold');
const diffEl = document.getElementById('diff');
const softEl = document.getElementById('soft');
const thVal = document.getElementById('thVal');
const diffVal = document.getElementById('diffVal');
const softVal = document.getElementById('softVal');

const playOverlay = document.getElementById('playOverlay');
const playBtn = document.getElementById('playBtn');
const noticeBox = document.getElementById('noticeBox');
const errorBox = document.getElementById('errorBox');

let off = document.createElement('canvas');
let offCtx = off.getContext('2d');
let animationId = null;
let usingChroma = true;
let scheduledTimer = null;
let currentVideoObj = null;

/* Lista de vídeos: cada uno con su preset de chroma */
const videoList = [
  { id: 'hola', src: 'hola.mp4', preset: { threshold: 0.25, diff: 0, soft: 100 } },
  { id: 'rem',  src: 'rem.mp4',  preset: { threshold: 0.50, diff: 40, soft: 30  } }
];

/* UTIL: seleccionar vídeo aleatorio distinto del actual (si posible) */
function pickRandomVideo(excludeId) {
  if (!videoList || videoList.length === 0) return null;
  if (videoList.length === 1) return videoList[0];
  const candidates = videoList.filter(v => v.id !== excludeId);
  if (candidates.length === 0) return videoList[Math.floor(Math.random()*videoList.length)];
  return candidates[Math.floor(Math.random()*candidates.length)];
}

/* Mostrar/ocultar controles según protocolo */
function setupControlsByProtocol() {
  if (protocol === 'file:') {
    controls.style.display = 'block';
  } else {
    controls.style.display = 'none';
  }
}

/* Ajustar tamaño del contenedor según la relación de aspecto del vídeo */
function adjustContainerToVideo(video) {
  const vw = video.videoWidth || 16;
  const vh = video.videoHeight || 9;
  const maxW = Math.min(window.innerWidth * 0.7, 900);
  const maxH = Math.min(window.innerHeight * 0.7, 900);
  const scale = Math.min(maxW / vw, maxH / vh, 1.0);
  const displayW = Math.max(120, Math.round(vw * scale));
  const displayH = Math.max(80, Math.round(vh * scale));
  fgContainer.style.width = displayW + 'px';
  fgContainer.style.height = displayH + 'px';
  fgCanvas.width = displayW;
  fgCanvas.height = displayH;
  // Offscreen: use video natural resolution with a cap for performance
  const cap = 1280;
  off.width = Math.min(video.videoWidth || displayW*2, cap);
  off.height = Math.min(video.videoHeight || displayH*2, cap);
}

/* Chroma-key */
function applyChromaKey(imageData, settings) {
  const data = imageData.data;
  const len = data.length;
  const thresh = settings.threshold;
  const minDiff = settings.diff;
  const soften = settings.soft;
  for (let i = 0; i < len; i += 4) {
    const r = data[i], g = data[i+1], b = data[i+2], a = data[i+3];
    if (a === 0) continue;
    const maxrb = Math.max(r,b);
    const sum = r + g + b + 1;
    const greenScore = (g - maxrb) / sum;
    const isGreenCandidate = (g - maxrb) > minDiff && greenScore > (thresh - 0.2);
    if (!isGreenCandidate) {
      data[i+3] = 255;
      continue;
    }
    const diff = g - maxrb;
    if (soften <= 0) {
      data[i+3] = (diff > minDiff) ? 0 : 255;
    } else {
      const t = (diff - minDiff) / soften;
      const clamped = Math.max(0, Math.min(1, t));
      data[i+3] = Math.round((1 - clamped) * 255);
    }
  }
  return imageData;
}

/* Dibujar processed off canvas en fgCanvas con 'contain' para no recortar */
function drawProcessedToScreen() {
  const cw = fgCanvas.width, ch = fgCanvas.height;
  const vw = off.width, vh = off.height;
  ctx.clearRect(0,0,cw,ch);
  if (vw === 0 || vh === 0) return;
  const scale = Math.min(cw / vw, ch / vh);
  const dw = Math.round(vw * scale);
  const dh = Math.round(vh * scale);
  const dx = Math.round((cw - dw) / 2);
  const dy = Math.round((ch - dh) / 2);
  ctx.drawImage(off, 0, 0, vw, vh, dx, dy, dw, dh);
}

/* Processing loop */
function processLoop(video, currentVideoObj) {
  if (!usingChroma) return;
  if (video.paused || video.ended) {
    animationId = requestAnimationFrame(()=>processLoop(video, currentVideoObj));
    return;
  }

  if (video.videoWidth && video.videoHeight &&
      (off.width !== Math.min(video.videoWidth,1280) || off.height !== Math.min(video.videoHeight,1280))) {
    off.width = Math.min(video.videoWidth,1280);
    off.height = Math.min(video.videoHeight,1280);
  }

  try {
    offCtx.drawImage(video, 0, 0, off.width, off.height);
  } catch (err) {
    console.error('drawImage error (posible CORS):', err);
    activateFallback('No se pudieron leer píxeles (CORS). Mostrando vídeo sin recorte.');
    return;
  }

  let frame;
  try {
    frame = offCtx.getImageData(0, 0, off.width, off.height);
  } catch (err) {
    console.error('getImageData error (CORS):', err);
    activateFallback('No se pudieron leer píxeles (CORS). Mostrando vídeo sin recorte.');
    return;
  }

  // settings: file:// -> controles; http(s) -> preset por vídeo
  let settings;
  if (protocol === 'file:') {
    settings = {
      threshold: parseFloat(thresholdEl.value),
      diff: parseInt(diffEl.value, 10),
      soft: parseInt(softEl.value, 10)
    };
  } else {
    settings = currentVideoObj && currentVideoObj.preset ? currentVideoObj.preset : { threshold:0.4, diff:30, soft:30 };
  }
  thVal.textContent = settings.threshold.toFixed(2);
  diffVal.textContent = settings.diff;
  softVal.textContent = settings.soft;

  const processed = applyChromaKey(frame, settings);
  offCtx.putImageData(processed, 0, 0);
  drawProcessedToScreen();

  animationId = requestAnimationFrame(()=>processLoop(video, currentVideoObj));
}

/* Activar fallback: mostrar el video tal cual (sin chroma) */
function activateFallback(message) {
  usingChroma = false;
  fgCanvas.style.display = 'none';
  fgVideo.style.display = 'block';
  noticeBox.textContent = message || 'Chroma-key no disponible; mostrando vídeo sin recorte.';
  noticeBox.style.display = 'block';
  if (animationId) cancelAnimationFrame(animationId);
  fgVideo.play().catch(()=>{ playOverlay.style.display = 'flex'; });
  showContainer(); // aseguramos visibilidad
}

/* Elegir posición aleatoria (left o right) antes de mostrar */
function placeContainerRandomly() {
  const leftOrRight = Math.random() < 0.5 ? 'left' : 'right';
  // reset both then set chosen
  fgContainer.style.left = '';
  fgContainer.style.right = '';
  if (leftOrRight === 'left') fgContainer.style.left = '20px';
  else fgContainer.style.right = '20px';
  // for very small screens we keep a small offset
  if (window.innerWidth < 420) {
    if (leftOrRight === 'left') fgContainer.style.left = '12px';
    else fgContainer.style.right = '12px';
  }
}

/* Mostrar container con animación (colocar aleatoriamente primero) */
function showContainer() {
  // position randomly each time it's shown
  placeContainerRandomly();
  fgContainer.style.display = 'flex';
  fgContainer.classList.remove('exit');
  requestAnimationFrame(()=> fgContainer.classList.add('enter'));
}

/* Ocultar container (transición) */
function hideContainerInstantlyForTransition() {
  fgContainer.classList.remove('enter');
  fgContainer.classList.add('exit');
}

/* scheduleNextVideo con delay (3s) */
function scheduleNextVideo(afterSeconds = 3, excludeId = null) {
  if (scheduledTimer) {
    clearTimeout(scheduledTimer);
    scheduledTimer = null;
  }
  hideContainerInstantlyForTransition();
  scheduledTimer = setTimeout(() => {
    const next = pickRandomVideo(excludeId);
    if (!next) return;
    playVideoClip(next);
  }, afterSeconds * 1000);
}

/* Reproduce el clip infoObj */
function playVideoClip(infoObj) {
  if (!infoObj) return;
  currentVideoObj = infoObj;
  usingChroma = true;
  fgVideo.src = infoObj.src;
  fgVideo.load();

  // En http(s) aplicamos presets del clip a los controles internos (aunque ocultos)
  if (protocol !== 'file:' && infoObj.preset) {
    thresholdEl.value = infoObj.preset.threshold;
    diffEl.value = infoObj.preset.diff;
    softEl.value = infoObj.preset.soft;
    thVal.textContent = parseFloat(infoObj.preset.threshold).toFixed(2);
    diffVal.textContent = infoObj.preset.diff;
    softVal.textContent = infoObj.preset.soft;
  }

  fgVideo.addEventListener('loadedmetadata', function onMeta() {
    fgVideo.removeEventListener('loadedmetadata', onMeta);
    adjustContainerToVideo(fgVideo);

    fgCanvas.style.display = 'block';
    fgVideo.style.display = 'none';

    const pVideoPlay = fgVideo.play().catch(()=>{});
    const pBgPlay = bgVideo.play().catch(()=>{});
    Promise.allSettled([pBgPlay, pVideoPlay]).then(results => {
      const anyRejected = results.some(r => r.status === 'rejected');
      if (anyRejected) playOverlay.style.display = 'flex';
      else playOverlay.style.display = 'none';
      if (!animationId && usingChroma) animationId = requestAnimationFrame(()=>processLoop(fgVideo, infoObj));
      showContainer();
    });

    // Cuando termine el clip, agarramos otro tras 3s
    fgVideo.onended = () => {
      scheduleNextVideo(3, infoObj.id);
    };
  });

  fgVideo.onerror = (e) => {
    console.error('Error cargando clip:', infoObj.src, e);
    activateFallback('Error cargando el clip. Mostrando fallback (sin recorte).');
  };
}

/* Inicialización */
function init() {
  setupControlsByProtocol();

  fgContainer.style.display = 'none';
  fgCanvas.style.display = 'none';
  fgVideo.style.display = 'none';

  // Click en el recuadro -> schedule next after 3s (exclude current)
  fgContainer.addEventListener('click', () => {
    if (scheduledTimer) {
      clearTimeout(scheduledTimer);
      scheduledTimer = null;
    }
    const currentSrc = fgVideo.src ? fgVideo.src.split('/').pop() : null;
    let currentId = null;
    if (currentSrc) {
      for (const v of videoList) {
        if (v.src.endsWith(currentSrc)) { currentId = v.id; break; }
      }
    }
    scheduleNextVideo(3, currentId);
  });

  // Play overlay button
  playBtn.addEventListener('click', () => {
    playOverlay.style.display = 'none';
    bgVideo.play().catch(()=>{});
    fgVideo.play().catch(()=>{});
  });

  // Controls UI updates (only relevant on file://)
  [thresholdEl, diffEl, softEl].forEach(el => el.addEventListener('input', () => {
    thVal.textContent = parseFloat(thresholdEl.value).toFixed(2);
    diffVal.textContent = diffEl.value;
    softVal.textContent = softEl.value;
  }));

  // Start with a random clip
  const first = pickRandomVideo(null);
  if (!first) return;
  playVideoClip(first);

  // On window resize, re-adjust container to current video aspect if available
  window.addEventListener('resize', () => {
    if (fgVideo.videoWidth && fgVideo.videoHeight) adjustContainerToVideo(fgVideo);
  });
}

/* Lanzar init */
init();

</script>
</body>
</html>
